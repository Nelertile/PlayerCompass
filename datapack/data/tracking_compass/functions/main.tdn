@ tag load

team add tc.no_collision
team modify tc.no_collision collisionRule never

forceload add -30000000 1499
setblock -30000000 1 1499 minecraft:yellow_shulker_box{Items:[]}
scoreboard objectives add tc.data dummy
scoreboard objectives add tc.id dummy

# takes some items and inserts them into the player's inventory
# starts at the specified slot
# eg usage: eval loot_shulker(pointer<tracking_compass:data~inventory>, "inventory.0")
var loot_shulker = function(items, slot) {
    # sets the contents of the shulker box to the items in the nbt pointer passed
    set (-30000000 1 1499).Items = ${items}
    # inserts the items in the shulker into the player's inventory, at the slot specified
    loot replace entity @s ${slot} mine -30000000 1 1499 air{drop_contents: 1b}
}

function tick {
    # for every player...
    as @a at @s function player {
        unless score @s tc.data isset function set_id {
            set #current_id->tc.data += 1
            set @s->tc.id = #current_id->tc.data
        }
        
        # if this has a villager but has no players next to him, try and kill the villager
        as @a[tag=!tracking_compass.found_player,tag=tracking_compass.has_villager] function kill_villager {
            tag @s add tracking_compass.current_player
            set @s->tc.data += 1
            set #id->tc.data = @s->tc.id
            as @e[tag=tracking_compass.villager] if score @s tc.id = #id tc.data tp ~ -5 ~
            if score @s tc.data matches 3.. function timeout {
                # resets the timer and marks this player as not having a villager
                set @s->tc.data = 0
                tag @s remove tracking_compass.has_villager
                # villager go bye bye
                as @e[tag=tracking_compass.villager] if score @s tc.id = #id tc.data kill @s
            } 
        }
        
        tag @s remove tracking_compass.found_player
        
        # creates a list of compasses
        set tracking_compass:data~compasses = []
        # sets this list to be all the tracking compasses in the player's inv.
        data modify storage tracking_compass:data compasses append from entity @s Inventory[{tag: {tracking_compass: {is_compass: 1b}}}]
        
        # if there's at least 1 compass, loop thru all of them
        if data storage tracking_compass:data compasses[0] function update_compasses {
            # searching for players nearby to position a villager so that the player can be interacted with
            if predicate tracking_compass:has_compass function player_search {
                tag @s add tracking_compass.current_player
                as @e[tag=!tracking_compass.current_player, distance=..6.5, sort=nearest, type=pig] function player_found {
                    # notifies the player that another player was found
                    as @a[tag=tracking_compass.current_player, limit=1] function {
                        tag @s add tracking_compass.found_player
                        set #id->tc.data = @s->tc.id
                        unless @s[tag=tracking_compass.has_villager] function summon_villager {
                            summon villager ~ -5 ~ {NoGravity:1b,Silent:1b,Invulnerable:1b,NoAI:1b,Team:tc.no_collision,Tags:["tracking_compass.villager", "tracking_compass.not_processed"],ActiveEffects:[{Id:11b,Amplifier:5b,Duration:600000,ShowParticles:0b},{Id:14b,Amplifier:0b,Duration:600000,ShowParticles:0b}]}
                            set @e[type=villager,tag=tracking_compass.not_processed]->tc.id = #id->tc.data
                            tag @e[type=villager] remove tracking_compass.not_processed
                            tag @s add tracking_compass.has_villager
                        }
                    }
                    
                    # caches the other player's id to update the villager later
                    set #other_id->tc.data = @s->tc.id
                    positioned as @s as @e[tag=tracking_compass.villager] if score @s tc.id = #id tc.data function update_villager {
                        # updates this villager's id with the found player's
                        set @s->tc.data = #other_id->tc.data
                        tp @s ^ ^ ^-1
                    }
                }
                tag @s remove tracking_compass.current_player
            }
            
            # setting up the inventory means creating arrays with *all* the items in your inventory, depending on which section of the inventory it is
            # eg. a list of all hotbar items, a list of all inventory items, etc.
            function setup_inventory {
                set tracking_compass:data~item = null
                set tracking_compass:data~offhand = null
                set tracking_compass:data~hotbar = []
                set tracking_compass:data~inventory = []
                set tracking_compass:data~items = @s.Inventory
                
                # loops thru each slot in the hotbar and appends its item to the hotbar list
                for (var i = 0; i < 9; i++) {
                    data modify storage tracking_compass:data hotbar append from storage tracking_compass:data items[{Slot: ${i as tag_byte}}]
                }
                # same for inventory, except we need to decrease the slot by 9 so it fits in the shulker box
                for (var i = 9; i < 36; i++) {
                    store success score #slot_full tc.data set tracking_compass:data~item = tracking_compass:data~items[{Slot: ${i as tag_byte}}]
                    if score #slot_full tc.data matches 1 function {
                        set tracking_compass:data~item.Slot = ${i - 9}
                        data modify storage tracking_compass:data inventory append from storage tracking_compass:data item
                    }
                }
            }
            
            # recurrent function; loops thru every compass
            at @s function loop {
                set tracking_compass:data~item = tracking_compass:data~compasses[0]
                set #slot->tc.data = tracking_compass:data~item.Slot
                
                # sets the dimension of the compass to match its target
                # TODO: currently matches the holder's dim; change to target
                set tracking_compass:data~item.tag.LodestoneDimension = @s.Dimension
                set #id->tc.data = tracking_compass:data~item.tag.tracking_compass.target
                as @e[type=pig] if score @s tc.id = #id tc.data tag @s add tracking_compass.tracked
                
                # updates the position the compass points to
                as @e[limit=1,tag=tracking_compass.tracked] function update_position {
                    store result storage tracking_compass:data item.tag.LodestonePos.X int 1 data get entity @s Pos[0]
                    store result storage tracking_compass:data item.tag.LodestonePos.Y int 1 data get entity @s Pos[1]
                    store result storage tracking_compass:data item.tag.LodestonePos.Z int 1 data get entity @s Pos[2]
                    tag @s remove tracking_compass.tracked
                }
                
                # if is in hotbar slots, add item to the hotbar list
                if score #slot tc.data matches 0..8 data modify storage tracking_compass:data hotbar append from storage tracking_compass:data item
                # if is in the offhand slot, set as the offhand item
                if score #slot tc.data matches -106 function {
                    set tracking_compass:data~offhand = tracking_compass:data~item
                    set tracking_compass:data~offhand.Slot = 0b
                }
                # if is in inventory slots, append to the inventory list
                # decreases slot num by 9 so it fits in the shulker later
                if score #slot tc.data matches 9..35 function {
                    set #slot->tc.data -= 9
                    set tracking_compass:data~item.Slot (byte) = #slot->tc.data
                    data modify storage tracking_compass:data inventory append from storage tracking_compass:data item
                }
                # Important: removes the first compass item from the list
                # this is what makes the loop work
                set tracking_compass:data~compasses[0] = null
                # if there still are compasses, continue looping
                if data storage tracking_compass:data compasses[0] function /
            }
            
            # loots the shulker for each section of the inventory accordingly
            eval loot_shulker(pointer<tracking_compass:data~hotbar>, 'hotbar.0')
            eval loot_shulker(pointer<tracking_compass:data~inventory>, 'inventory.0')
            if data storage tracking_compass:data offhand expand {
                # won't loot the offhand if there's no offhand item
                set tracking_compass:data~offhand_list = []
                data modify storage tracking_compass:data offhand_list append from storage tracking_compass:data offhand
                eval loot_shulker(pointer<tracking_compass:data~offhand_list>, 'weapon.offhand')
            }
        }        
    }
    
    schedule function / 10
}
